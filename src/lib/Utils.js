/*
  Utils.js V. 0.3.0
*/
// require('./commands').forEach(function (command) {
//  require('./Utils/' + command);
//});
("use strict");

let shell = require("shelljs");
let fs = require("fs");
let os = require("os");
let dns = require("dns");
let network = require("network");

let Utils = function() {};

Utils.prototype.netNetmask = function() {
  var netMask="";
  var ifaces = os.networkInterfaces();

  Object.keys(ifaces).forEach(function (ifname) {
    var alias = 0;

    ifaces[ifname].forEach(function (iface) {
      if ('IPv4' !== iface.family || iface.internal !== false) {
        // skip over internal (i.e. 127.0.0.1) and non-ipv4 addresses
        return;
      }
      netMask= iface.netmask;
    });
  });
  return netMask;
};

Utils.prototype.netDomainName = function() {
  return "lan";
};

Utils.prototype.netDns = function() {
  return dns.getServers()[0];
};

Utils.prototype.netGateway = function() {
  return "192.168.0.1";
}

Utils.this.netDomainName = function(){
  return "lan";
}

Utils.prototype.netBootServer = function() {
  let ip = require("ip");
  return ip.address();
};

Utils.prototype.netDeviceName = function() {
  let interfaces = Object.keys(os.networkInterfaces());
  let netDeviceName = "";
  for (let k in interfaces) {
    if (interfaces[k] != "lo") {
      netDeviceName = interfaces[k];
    }
  }
  return netDeviceName;
};

Utils.prototype.kernerlVersion = function() {
  return os.release();
};

Utils.prototype.isRoot = function() {
  return process.getuid && process.getuid() === 0;
};

Utils.prototype.bashwrite = function(file, text) {
  const head = `########################################################START##
# Generated by Egg ${file.trim()}
###############################################################\n`;
  const footer = `######################################################## END ##
`;

  console.log(`[Utils]\n>>> Creazione ${file}`);
  text = head + text.trim() + "\n" + footer;
  text = text.trim() + "\n";
  file = file.trim();
  fs.writeFileSync(file, text);
  console.log(text);
  console.log(`>>> Fine creazione ${file}  ===`);
};

Utils.prototype.exec = function(cmd) {
  console.log(`[Utils] >>> exec ${cmd}`);
  shell.exec(cmd);
};

Utils.prototype.rsync = function(commands) {
  //console.log(`[Utils] >>> rsync ${commands}`);
  commands.forEach(function(cmd) {
    // Questa riga, mandava rsync in async...
    //const { stdout, stderr, code } =  shell.exec(cmd, { silent: true });
    console.log(`[Utils] >>> exec ${cmd}`);
    shell.exec(cmd, { async: false });
  });
};

Utils.prototype.sr = function(file, search, replace) {
  let original = fs.readFileSync(file).toString();
  let changed = original.replace(search, replace);
  fs.writeFileSync(file, changed);
};

/**
 *
 * Funzioni interne: calcolo rete; copiate da ipcalc
 *
 */

var MAX_BIT_BIN = 255;
/**
 * ANDs 32 bit representations of IP and submask to get network address
 *
 * @param {number} 32 bit representation of IP address
 * @param {number} 32 bit representation of submask
 * @return {number} 32 bit representation of IP address (network address)
 */
Utils.prototype.net = function(ip, sm) {
  let _ip = qdotToInt(ip.split("."));
  let _sm = qdotToInt(sm.split("."));
  return intToQdot(_ip & _sm);
};

/**
 * Reverses function qdotToInt(ip)
 *
 * @param {number} a 32-bit integer representation of an IPv4 address
 * @return {string} a quad-dotted IPv4 address
 */
function intToQdot(integer) {
  return [
    (integer >> 24) & MAX_BIT_BIN,
    (integer >> 16) & MAX_BIT_BIN,
    (integer >> 8) & MAX_BIT_BIN,
    integer & MAX_BIT_BIN
  ].join(".");
}

/**
 * Converts an IP/Submask into 32 bit int
 *
 * @param {Array.<string>} a quad-dotted IPv4 address -> array
 * @return {number} a 32-bit integer representation of an IPv4 address
 */
function qdotToInt(ip) {
  var x = 0;

  x += +ip[0] << 24 >>> 0;
  x += +ip[1] << 16 >>> 0;
  x += +ip[2] << 8 >>> 0;
  x += +ip[3] >>> 0;

  return x;
}

module.exports = new Utils();
