/*
  chickenEggBoot.js V. 0.3.0
*/

"use strict";

class Netboot {
  constructor(homeDir = "/home/artisan/fabricator", distroName = "Fabricator") {
    //super(homeDir, distroName);

    this.fsDir=homeDir+`${distroName}/fs`;
    this.clientUserFullName = clientUserFullName;
    this.clientUserName = clientUserName;
    this.clientPassword = clientPassword;
    this.clientIpAddress = "127.0.1.1";
    this._kernelVer = os.release();

    let interfaces = Object.keys(os.networkInterfaces());
    let iface = "";
    for (let k in interfaces) {
      if (interfaces[k] != "lo") {
        iface = interfaces[k];
      }
    }
    this._netDeviceName = iface;

    this._isoDir = homeDir + "/iso";
  }

  vmlinuz() {
    execShow(`mkdir -p ${this.tftpRoot}/${this.distroName}`);
    console.log(`### Copia di vmlinuz-${this.kernelVer} ###`);
    execShow(
      `cp /boot/vmlinuz-${this.kernelVer}  ${this.tftpRoot}/${this.distroName}`
    );
    execShow(`chmod -R 777  ${this.tftpRoot}`);
  }

  initramfs() {
    console.log(`### creazione initramfs ###`);

    let conf = `/etc/initramfs-tools/initramfs.conf`;
    let initrdFile = `/tmp/initrd.img-${this.kernelVer}`;

    let search = "MODULES=most";
    let replace = "MODULES=netboot";
    fileSearchReplace(conf, search, replace);

    search = "BOOT=local";
    replace = "BOOT=nfs";
    fileSearchReplace(conf, search, replace);

    execShow(`mkinitramfs -o /tmp/initrd.img-${this.kernelVer}`);

    console.log(`### Copia di initrd.img-${this.kernelVer} ###`);
    execShow(`cp ${initrdFile}  ${this.tftpRoot}/${this.distroName}`);
    console.log(`### file initramfs ###`);
  }

  pxelinux() {
    execAndShow(`mkdir -p ${this._tftpRoot}/pxelinux.cfg`);
    let file = `${this._tftpRoot}/pxelinux.cfg/default`;
    let text = `# Generated by eggs
DEFAULT vesamenu.c32
TIMEOUT 600
ONTIMEOUT BootLocal
PROMPT 0
KBDMAP it.kbd
DISPLAY display.txt
SAY Uso la tastiera e locale per italiano.
MENU TITLE Giant-Turle
MENU BACKGROUND wallpaper.png

LABEL ${this._distroName}
MENU LABEL ${this._distroName}
KERNEL ${this._distroName}/vmlinuz-${this._kernelVer}
APPEND root=/dev/nfs initrd=${this._distroName}/initrd.img-${this
      ._kernelVer} nfsroot=${this._netBootServer}:${this._fsDir} ip=dhcp rw
IPAPPEND 3
TEXT HELP
Distribuzione con boot remoto ${this._distroName}
ENDTEXT
# parametro per eth0 net.ifnames=0
#LABEL ========================================================================
#LABEL Avvio da immagini ISO con memdisk - Selezionare immagine desiderata
#LABEL ========================================================================
#LABEL WinXP over HTTP
#	MENU LABEL WinXP over HTTP
#		LINUX /memdisk
#		INITRD /iso/WinXP.iso
#		APPEND iso

LABEL ========================================================================
LABEL Boot locale
localboot 0
TEXT HELP
Esegue il boot dal disco locale
ENDTEXT

include common.cfg`;

    writeAndShow(file, text);

    shell.exec(`ln /usr/lib/PXELINUX/pxelinux.0  ${this._tftpRoot}/pxelinux.0`);
    shell.exec(
      `ln /usr/lib/PXELINUX/lpxelinux.0  ${this._tftpRoot}/lpxelinux.0`
    );
    shell.exec(`ln src/assets/wallpaper.png ${this._tftpRoot}/wallpaper.png`);

    shell.exec(
      `ln /usr/lib/syslinux/modules/bios/vesamenu.c32 ${this
        ._tftpRoot}/vesamenu.c32`
    );
    shell.exec(
      `ln /usr/lib/syslinux/modules/bios/ldlinux.c32 ${this
        ._tftpRoot}/ldlinux.c32`
    );
    shell.exec(
      `ln /usr/lib/syslinux/modules/bios/libcom32.c32 ${this
        ._tftpRoot}/libcom32.c32`
    );
    shell.exec(
      `ln /usr/lib/syslinux/modules/bios/libutil.c32 ${this
        ._tftpRoot}/libutil.c32`
    );
    shell.exec(`ln /usr/lib/syslinux/memdisk ${this._tftpRoot}/memdisk`);
  }

  exports() {
    let file = `/etc/exports`;
    let text =
      bashHeader +
      `${this._fsDir} ${this._net}/${this
        ._netNetmask}(rw,no_root_squash,async,no_subtree_check)
### Attenzione NON lasciare spazi tra le opzioni ###`;

    writeAndShow(file, text);
  }

  dnsmasq() {
    let file = `/etc/dnsmasq.conf`;
    let text = `
interface=${this._netDeviceName}
domain=lan
dhcp-range=${this._net}, proxy, ${this._netNetmask}
pxe-service=x86PC, "Eggs and penguins...", pxelinux
enable-tftp
port=0
tftp-root=${this._tftpRoot}
# IF dhcp-match=set:ipxe,175 THEN
dhcp-match=set:ipxe,175 # iPXE sends a 175 option.
      dhcp-boot=tag:!ipxe,undionly.kpxe
#ELSE
      dhcp-boot=http://${this._netBootServer}/lpxelinux.0
# ENDIF`;

    writeAndShow(file, text);
  }
}
